### 单例模式（Singleton Pattern）

`这是Java中最简单的设计模式之一。
这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。
这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。`

注意：

1. 单例类只能有一个实例
2. 单例类必须自己创建自己的唯一实例
3. 单例类必须给所有其他对象提供这一实例

## 介绍

**意图：** 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**主要解决：** 一个全局使用的类频繁的创建与销毁。

**何时使用：** 当你想控制实例数目，节省系统资源的时候。

**如何解决：** 判断系统是否已有这个单例，如果有则返回，如果没有则创建

**关键代码：** 构造函数时私有的。

**应用实例：** 

1. 一个党只能有一个主席。
2. Windows是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有的文件的处理必须通过唯一的实例来进行。
3. 一些设备管理器常常设计为单例模式，比如一个电脑有两个打印机，在输出的时候就要处理不能两台打印机打印同一个文件。

**优点：** 

1. 在内存只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）
2. 避免对资源的多重占用（比如写文件操作）

**缺点：** 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化

**应用场景：** 

1. 要求生成唯一序列号。
2. Web中计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
3. 创建的一个对象需要消耗的资源过多，比如I/O与数据库的连接等

**注意事项：** getInstance()方法中需要使用同步锁synchronize(Singleton.class)放置多线程同时进入造成Singleton被多次实例化。

## 实现

创建一个SingletonObject类。该类有它的私有构造函数和本身的一个静态实例。
SingletonObject类提供了一个静态的方法，供外界获取它的静态实例。
SingletonPatternDemo测试使用SingletonObject类来获取SingletonObject对象

SingletonPatternDemo（+main(): void）
--asks-- >
< --returns--
SingletonObject（-instance: SingletonObject, -SingletonObject(), +getInstance(): SingletonObject, +showMessage(): void）

**步骤1：** 创建一个Singleton类 -- > SingletonObject.java

**步骤2：** 从Singleton类获取唯一的对象。-- > SingletonPatternDemo.java

**步骤3：** 验证结果 Hello World！

## 单例模式的几种实现方式

1. 懒汉式，线程不安全   
2. 懒汉式，线程安全地
3. 饿汉式
4. 双检索/双重检验锁（DCL, 即double-checked locking）
5. 登记式/静态内部类
6. 枚举

| 方式               |    是否Lazy初始化 | 是否多线程安全 | 实现难度 | 描述  |
| :--------          | :--:| :--:| :--:| :-------- |
| 懒汉式, 线程不安全  | 是 |  否 |  易 |  最基本，不支持多线程，没有加锁synchronize,所以严格意义上来说它并不算单例模式 |
| 懒汉式, 线程安全    |   是 |  是 |  易 |  效率低，99%的情况下无需同步；第一次调用时初始化，避免内存浪费；必须加锁synchronize才能保证单例，但加锁会影响效率；getInstance()的性能对应用程序不是很关键（该方法使用不太频繁） |
| 饿汉式             |    否 | 是 | 易 | 比较常用，容易产生垃圾对象；没有加锁，运行效率会有提高；类加载时就初始化，浪费内存； |
| DCL(JDK1.5+)               |    是 | 是 | 较复杂 | 采用双检锁机制，安全且多线程情况下能保持高性能，getInstance()的性能对应用程序很关键 |
| 登记式             |    是 | 是 | 一般 | 对静态域使用延迟初始化 |
| 枚举(JDK1.5+)      |    否 | 是 | 易 | 最佳方法，没有被广泛使用，自动支持序列化机制，绝对防止多次实例化 |

**建议：**

一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。
